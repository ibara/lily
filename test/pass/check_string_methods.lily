var total = 0, failed = 0

define ok(b: Boolean, s: String)
{
    total += 1

    if b == false: {
        stderr.write("Test {0} ({1}) failed.\n".format(total, s))
        failed += 1
    }
}

ok("1".ends_with("2") == false,     "String.ends_with '1' and '2'.")
ok("1".ends_with("12345") == false, "String.ends_with '1' and '12345'.")
ok("1".ends_with("1"),              "String.ends_with '1' and '1'.")
ok("ÀÈÌaÒÜ".ends_with("aÒÜ"),       "String.ends_with utf-8 success case.")

ok("12".find("1").is_some(),       "String.find with '12' and '1'.")
ok("ÀÈaÌÒÜ".find("ÈaÌ").is_some(), "String.find utf-8 success case.")
ok("1".find("12345").is_none(),    "String.find where needle exceeds haystack.")
ok("".find("").is_none(),          "String.find where haystack is empty.")
ok("1234".find("5").is_none(),     "String.find needle not in haystack.")
ok("1234".find("1", 9).is_none(),  "String.find where start is past end.")
ok("1234".find("3", 2).is_some(),  "String.find where match begins at the start.")

ok((||
    var result = false
    try:
        "{".format(0)
    except ValueError:
        result = true

    result)(),                       "String.format fails on unterminated specifier.")

ok((||
    var result = false
    try:
        "{a}".format(0)
    except ValueError:
        result = true

    result)(),                       "String.format fails on {a}.")

ok((||
    var result = false
    try:
        "{100}".format(0)
    except ValueError:
        result = true

    result)(),                       "String.format fails on {100}.")

ok((||
    var result = false
    try:
        "{}".format(0)
    except ValueError:
        result = true

    result)(),                       "String.format fails on {}.")

ok((||
    var result = false
    try:
        "{5}".format(0)
    except IndexError:
        result = true

    result)(),                       "String.format fails on an index that's too large.")

ok("{0}{0}".format(0) == "00",       "String.format works for {0}{0}.")
ok("{00000000}".format(0) == "0",    "String.format works on leading zeroes.")
ok("{1}a{2}".format(0,1,2) == "1a2", "String.format works for {1}a{2}.")
ok("abc".format(0,1,2) == "abc",     "String.format for unformatted input.")

ok("<&>".html_encode() == "&lt;&amp;&gt;",     "String.html_encode full spectrum.")
ok("+<&>+".html_encode() == "+&lt;&amp;&gt;+", "String.html_encode without replacing start + end.")
ok("<+&+>".html_encode() == "&lt;+&amp;+&gt;", "String.html_encode with text interleaving replacements.")

ok("".is_alnum() == false,                    "String.is_alnum empty false case.")
ok("a".is_alnum(),                            "String.is_alnum with true case.")
ok("abc123()".is_alnum() == false,            "String.is_alnum denies partial alpha.")

ok("".is_alpha() == false,                    "String.is_alpha empty false case.")
ok("a".is_alpha(),                            "String.is_alpha with true case.")
ok("abc123".is_alpha() == false,              "String.is_alpha denies partial alpha.")

ok("".is_digit() == false,                    "String.is_digit empty false case.")
ok("123".is_digit(),                          "String.is_digit with true case.")
ok("abc123".is_digit() == false,              "String.is_digit denies partial digit.")

ok("".is_space() == false,                    "String.is_space empty false case.")
ok(" \t\r\n".is_space(),                      "String.is_space full spectrum true case.")
ok("abc ".is_space() == false,                "String.is_space denies partial space.")

ok("abc".lstrip("") == "abc",                 "String.lstrip empty remove string.")
ok("aabbab12".lstrip("ab") == "12",           "String.lstrip multi remove.")
ok("aaaaa".lstrip("a") == "",                 "String.lstrip removing all.")
ok("ÀÈaÌÒÜ".lstrip("ÀÈ") == "aÌÒÜ",           "String.lstrip with utf-8 chunk.")

ok("abc".lower() == "abc",                    "String.lower ignores 'abc'.")
ok("ABC".lower() == "abc",                    "String.lower basic success case.")

ok("+12345".parse_i().unwrap() == 12345,       "String.parse_i positive lead.")
ok("0001".parse_i().unwrap() == 1,             "String.parse_i leading zeroes.")
ok("9223372036854775807".parse_i().unwrap() == 9223372036854775807,
                                               "String.parse_i parses int max.")
ok("-9223372036854775808".parse_i().unwrap() == -9223372036854775808,
                                               "String.parse_i parses int min.")
ok("".parse_i().is_none(),                     "String.parse_i fails with empty string.")
ok("9223372036854775808".parse_i().is_none(),  "String.parse_i rejects int max + 1.")
ok("-9223372036854775809".parse_i().is_none(), "String.parse_i rejects int min - 1.")
ok("123abc".parse_i().is_none(),               "String.parse_i rejects '123abc'.")
ok("0".parse_i().is_some(),                    "String.parse_i parses 0.")

ok("abc".replace("", "") == "abc",             "String.replace does nothing for empty input.")
ok("abc".replace("abcd", "0") == "abc",        "String.replace ignores too-long input.")
ok("a-b-c".replace("-", "+") == "a+b+c",       "String.replace single character in middle.")
ok("-abc-".replace("-", "+") == "+abc+",       "String.replace single character at edges.")
ok("---".replace("---", "") == "",             "String.replace all to nothing.")
ok("a--b--c--".replace("--", "+") == "a+b+c+", "String.replace multi character.")

ok("abc".rstrip("") == "abc",                  "String.rstrip empty remove string.")
ok("12aabbab".rstrip("ab") == "12",            "String.rstrip multi remove.")
ok("aaaaa".rstrip("a") == "",                  "String.rstrip removing all.")
ok("ÀÈaÌÒÜ".rstrip("ÌÒÜ") == "ÀÈa",            "String.rstrip with utf-8 chunk.")

ok("abc".slice() == "abc",                     "String.slice defaults copy the string.")
ok("abc".slice(0, -1) == "ab",                 "String.slice basic 0...-1 works.")
ok("abc".slice(1, 2) == "b",                   "String.slice basic 1...2 works (b).")
ok("abc".slice(2, 1) == "",                    "String.slice gives empty string for reversed indexes.")
ok("abc".slice(1, 5) == "",                    "String.slice gives empty string for too big indexes.")
ok("À".slice(0, 1) == "",                      "String.slice gives empty string instead of broken utf-8.")

ok("123".starts_with("12345") == false,        "String.starts_with '123' and '12345'.")
ok("1".starts_with("1"),                       "String.starts_with '1' and '1'.")
ok("ÀÈÌaÒÜ".starts_with("ÀÈ"),                 "String.starts_with utf-8 success case.")

ok("1".starts_with("2") == false,              "String.starts_with '1' and '2'.")
ok("123".starts_with("12345") == false,        "String.starts_with '123' and '12345'.")
ok("1".starts_with("1"),                       "String.starts_with '1' and '1'.")
ok("ÀÈÌaÒÜ".starts_with("ÀÈ"),                 "String.starts_with utf-8 success case.")

ok("123".split(" ") == ["123"],                "String.split no match.")
ok("1 2 3".split(" ") == ["1", "2", "3"],      "String.split simple success case.")
ok("1 2 3".split() == ["1", "2", "3"],         "String.split default to split by ' '.")
ok("1ab2ab".split("ab") == ["1", "2", ""],     "String.split split by wide ascii.")
ok("1ÀÀ2À".split("À") == ["1", "", "2", ""],   "String.split with utf-8 chunk.")
ok("   ".split(" ") == ["", "", "", ""],       "String.split where all chars match.")
ok("abc.def".split(".xyz") == ["abc.def"],     "String.split with incomplete match.")
ok((||
    var result = false
    try:
        "a".split("")
    except ValueError:
        result = true
    result
    )(),                                       "String.split raises ValueError for empty string.")
ok("1 2 3".split(" ")[0].is_digit(),           "String.split doesn't generate a broken first string.")

ok("abc".to_bytestring() == B"abc",            "String.to_bytestring basic success case.")

ok("abc".trim() == "abc",                      "String.trim ignores non-spaces.")
ok(" \t\r\nabc\t\r\n ".trim() == "abc",        "String.trim spectrum removal.")
ok("    ".trim() == "",                        "String.trim removing everything.")

ok("ABC".upper() == "ABC",                     "String.upper ignores 'ABC'.")
ok("abc".upper() == "ABC",                     "String.upper basic success case.")

if failed == 0:
    print("{0} of {0} tests passed.".format(total))
else:
    stderr.write("{0} tests have failed.\n".format(failed))
